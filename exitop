#! /usr/bin/perl
#
# Exitop
# Matthew Newton
# 24 October 2008
# $Format:%H% d$


use strict;
use Data::Dumper;
use Curses;
use Fcntl;

$SIG{INT} = \&sig;
$SIG{ALRM} = \&sig;
$SIG{WINCH} = \&sig;

my $redraw = 0;
my $alarm = 1;
my $alarmed = 0;
my $sig_winch = 0;
my $tidyup = 10;
my $tidycount = 0;
my $blocksize = 1024*1024;

alarm $alarm;

my $debug = 0;
my $highlightafter = 300; # highlight entries after 5 minutes

my $stats = {};
my $messages = {};

my $screen = {};
screen_init();
add_windows($screen);
addstr(0,0, "exitop 0.01");
redraw();

# setup bitmaps for select, to watch stdin and keypresses
my $srin = "";
my $srout;
vec($srin, fileno(STDIN), 1) = 1;
vec($srin, fileno($$screen{terminfd}), 1) = 1;

if (!fcntl(STDIN, F_SETFL, O_NONBLOCK)) {
  screen_end();
  die "cannot set STDIN to non-blocking mode";
}

#$$logs{"-"} = {"fn" => fileno(STDIN), "fh" => *STDIN{IO}, "buf" => ""};

# hash of all files to watch - contains:
#  key: filename
#  fh - filehandle (or undef if not open)
#  len - file size
#  buf - stuff read from file but not yet processed

my $logs = {};
foreach my $file (@ARGV) {
  if (! -r $file) {
    die "cannot read file $file";
  }
  next if defined($$logs{$file});

  $$logs{$file} = {buf => "", fh => undef, len => undef, tb => 0};
#  my $fh;
#  sysopen($fh, $file, O_RDONLY | O_NONBLOCK);
#  $$logs{$file}{fh} = $fh;
#  $$logs{$file}{fn} = fileno($fh);
}

my $delay = 0;

while (1) {
# check for keypresses or stdin input
  my $n = select($srout = $srin, undef, undef, $delay);
  $delay = $alarm;

  my $v = unpack("b*", $srout) . "    ";
  addstr(0,40, "vec: $v");

  if (vec($srout, fileno($$screen{terminfd}), 1) == 1) {
    my $key = getch();
    addstr(0, 70, $key) unless $key == -1;
    last if $key eq 'q';
    redraw() if $key eq chr(12);
  }

  if (vec($srout, fileno(STDIN), 1) == 1) {
    my $line = <STDIN>;
    addline($line);
  }

  my $status = "";

  foreach my $file (keys %$logs) {
    my @st = stat($file);
    my $flen = $st[7];

    # skip this file if length is 0, or unchanged
    $$logs{$file}{len} = $flen unless defined $$logs{$file}{len};
    $status .= "$file:" . $$logs{$file}{tb} . "/$flen ";
    next if $flen == 0 or $flen == $$logs{$file}{len};
    $$logs{$file}{len} = $flen;

    # should be something new to read - open file if required
    unless (defined $$logs{$file}{fh}) {
      sysopen($$logs{$file}{fh}, $file, O_RDONLY | O_NONBLOCK);
      sysseek($$logs{$file}{fh}, -$blocksize, 2);
      $$logs{$file}{tb} = $flen - $blocksize;
    }

    $delay = 0 if getfromfile($$logs{$file});
  }

#  addstr(1,0,$status);

  if ($alarmed) {
    redraw();
    $alarmed = 0;
    alarm $alarm;

    $tidycount--;
    if ($tidycount < 1) {
      tidy($stats);
      $tidycount = $tidyup;
    }
  }
}

finish();


#===============================================================================

sub getfromfile
{
  my $finfo = shift;
  my $str;
  my $loop = 5;

  my $bytes;
  my $count = 0;
#  do {
    $bytes = sysread($$finfo{fh}, $str, $blocksize);
    $$finfo{buf} .= $str;
    $$finfo{tb} += $bytes;

    my $pos = 0;
    while ((my $nl = index($$finfo{buf}, "\n", $pos)) > -1) {
      my $line = substr($$finfo{buf}, $pos, $nl - $pos);
      chomp $line;

      addline($line);
    
      $pos = $nl + 1;
    }

    $$finfo{buf} = substr($$finfo{buf}, $pos);
#  } while ($count++ < $loop and $bytes > 0 and !$alarmed);

  return length($$finfo{buf});
}


#===============================================================================

sub addline
{
  my $line = shift;
  my @bits;
  my ($date, $time, $timezone);

  loglinehook(\$line);

  @bits = split(/\s+/, $line);
  ($date, $time, $timezone, @bits) = @bits;
  
  # should be calculated from log line, not use time()
  my $msgtime = time();

  my $id;
  my $msg;
  my @statometer;

  # message id
  if ($bits[0] =~ /^[[:alnum:]]{6}-[[:alnum:]]{6}-[[:alnum:]]{2}$/) {
    $id = $bits[0];
    push @statometer, ["id", $bits[0]];
  }

  if (defined $id) {
    $$messages{$id} = { rcpts => [],
                        rcptdomains => [],
                        id => $id,
                        count => 0 } if ! defined $$messages{$id};
    $msg = $$messages{$id};
  }

  $$msg{lastseen} = $msgtime if defined $msg;

  # FROM <= lines
  if ($line =~ /\s<=\s([^\s]+@([^@\s]+))\s/ ) {
    $$msg{from} = $1 if defined $msg;
    $$msg{fromdomain} = $2 if defined $msg;

    push @statometer, ["from", $1];
    push @statometer, ["fdomain", $2];

    # from host
    if ($line =~ /\sH=([^ ]+)\s/) {
      $$msg{fhost} = $1 if defined $msg;
      push @statometer, ["fhost", $1];
    }

    # subject (multiword "delimited")
    if ($line =~ s/\sT="(.*[^\\])"//) {
      $$msg{subject} = $1 if defined $msg;
      push @statometer, ["subject", $1];
    }
  }

  # TO => lines
  if ($line =~ /[=-]>\s([^\s]+@([^@\s]+))\s/) {
    push @{$$msg{rcpts}}, $1 if defined $msg;
    push @{$$msg{rcptdomains}}, $2 if defined $msg;

    push @statometer, ["rcpt", $1];
    push @statometer, ["rdomain", $2];

    # to host
    if ($line =~ /\sH=([^ ]+)\s/) {
      $$msg{rhost} = $1 if defined $msg;
      push @statometer, ["rhost", $1];
    }
  }

  foreach my $i (0..$#statometer) {
    my $s = $statometer[$i];
    $$stats{$$s[0]}{$$s[1]} = [0, 0, {}, $msgtime] unless defined $$stats{$$s[0]}{$$s[1]};
    $$stats{$$s[0]}{$$s[1]}[0]++;    # number seen
    $$stats{$$s[0]}{$$s[1]}[1] = $msgtime;   # last time seen
    if (!defined $$stats{$$s[0]}{$$s[1]}[2]{$id}) {
      $$stats{$$s[0]}{$$s[1]}[2]{$id} = $msg;  # hash of msgs for reference
      $$msg{count}++;
    }
    print "ref+ $$msg{id} $$msg{count} $$s[0] $$s[1]\n" if $debug;
  }
}


#===============================================================================

sub sig
{
  my $signame = shift;

  $sig_winch = 1 if $signame eq 'WINCH';
  $alarmed = 1 if $signame eq 'ALRM';

  finish() if $signame eq 'INT';
}


#===============================================================================

sub finish
{
  screen_end();
  exit(0);
}


#===============================================================================

sub redraw
{
  local *TTY;

  if ($sig_winch) {
    del_windows($screen);
    if (defined &TIOCGWINSZ) {
      open(TTY, "+<", "/dev/tty");
      my $winsize;
      unless (ioctl(TTY, &TIOCGWINSZ, $winsize="")) {
        die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
      }
      close(TTY);
      my ($row, $col, $xpixel, $ypixel) = unpack("S4", $winsize);
      resizeterm($row, $col);
    } else {
      screen_end();
      screen_init();
    }
    refresh();
    addstr(0, 30, COLS() . " x " . LINES());
    addstr(0, 45, getmaxx() . " x " . getmaxy());
    add_windows($screen);
    $sig_winch = 0;
  }

  foreach my $s (@{$$screen{windows}}) {
    draw_window($s, $stats);
  }

  addstr(0, 15, COLS() . " x " . LINES());
  refresh();
}


#===============================================================================

sub tidy
{
  my $s = shift;

  my $numperstat = 10;
  my $longesttime = 300; # remove stats if last message over 5 mins ago
  my $preservetime = 300; # preserve full message info for 5 mins
  my $preservenum = 5; # preserve at least 5 messages for each stat

  my $t = time() - $longesttime;
  my $pt = time() - $preservetime;

  foreach my $code (keys %$s) {
    foreach my $data (keys %{$$s{$code}}) {

      # delete statistic if older than $longesttime seconds
      if ($$s{$code}{$data}[1] < $t) {
        # todo - lower reference counts
        foreach my $msgid (keys %{$$s{$code}{$data}[2]}) {
          my $msg = ${$$s{$code}{$data}[2]}{$msgid};
          #${$$s{$code}{$data}[2]}{$msgid}{count}--;
          $$msg{count}--;
          print "ref_ $$msg{id} $$msg{count} $code $data\n" if $debug;
        }
        print "del  " . $$s{$code}{$data}[0] . " " . $$s{$code}{$data}[1] .
              " $code $data\n" if $debug;
        delete $$s{$code}{$data};
        next;
      }

      # go through each recorded message for the stat, and delete if too old,
      # but leave $preservenum behind for reference (may not be the latest)
      foreach my $msgid (keys %{$$s{$code}{$data}[2]}) {
        my $msg = ${$$s{$code}{$data}[2]}{$msgid};

        # delete no more if we have less than the required num to preserve
        last if scalar keys %{$$s{$code}{$data}[2]} <= $preservenum;

        # delete if last seen too long ago
        if ($$msg{lastseen} < $pt) {
          delete ${$$s{$code}{$data}[2]}{$msgid};
          $$msg{count}--;
          print "ref- $$msg{id} $$msg{count} $code $data\n" if $debug;
        }
      }
    }
  }

  foreach my $m (sort keys %$messages) {
    print "mesg $m -> (" . $$messages{$m}{count} . ")\n" if $debug;
    delete $$messages{$m} if $$messages{$m}{count} < 1;
  }

}


#===============================================================================

sub screen_init
{
#  initscr();
  my $termifd;
  my $termofd;

  sysopen($termifd, "/dev/tty", O_RDONLY | O_NONBLOCK);
  sysopen($termofd, "/dev/tty", O_WRONLY);
  $$screen{terminal} = newterm($ENV{TERM}, $termofd, $termifd);
  $$screen{terminfd} = $termifd;
  $$screen{termoutfd} = $termofd;
  cbreak();
  noecho();
#  halfdelay(0);

  # turn the cursor off; don't care where it is left
  curs_set(0);
  leaveok(1);

  # set up colours
  start_color();
  init_pair(1, COLOR_YELLOW, COLOR_BLACK); # colour to highlight stale entries
}


#===============================================================================

sub screen_end
{
  endwin();
}


#===============================================================================

sub add_windows
{
  my $screen = shift;

  my $s;
  $$screen{windows} = [];
  
  my $sh = int((LINES()-2)/4);

  my $line = 2;

  $s = {};
  $$s{code} = "from";
  $$s{title} = "From Address";
  $$s{width} = int(COLS()/2);
  $$s{height} = $sh;
  $$s{pos} = [$line, 0];
  $$s{window} = newwin($$s{height}, $$s{width}, $$s{pos}[0], $$s{pos}[1]);
  push @{$$screen{windows}}, $s;

  $s = {};
  $$s{code} = "rcpt";
  $$s{title} = "Recipient Address";
  $$s{width} = COLS() - int(COLS()/2);
  $$s{height} = $sh;
  $$s{pos} = [$line, int(COLS()/2)];
  $$s{window} = newwin($$s{height}, $$s{width}, $$s{pos}[0], $$s{pos}[1]);
  push @{$$screen{windows}}, $s;

  $line += $sh;

  $s = {};
  $$s{code} = "fdomain";
  $$s{title} = "From Domain";
  $$s{width} = int(COLS()/2);
  $$s{height} = $sh;
  $$s{pos} = [$line, 0];
  $$s{window} = newwin($$s{height}, $$s{width}, $$s{pos}[0], $$s{pos}[1]);
  push @{$$screen{windows}}, $s;

  $s = {};
  $$s{code} = "rdomain";
  $$s{title} = "Recipient Domain";
  $$s{width} = COLS() - int(COLS()/2);
  $$s{height} = $sh;
  $$s{pos} = [$line, int(COLS()/2)];
  $$s{window} = newwin($$s{height}, $$s{width}, $$s{pos}[0], $$s{pos}[1]);
  push @{$$screen{windows}}, $s;

  $line += $sh;

  $s = {};
  $$s{code} = "fhost";
  $$s{title} = "From Host";
  $$s{width} = int(COLS()/2);
  $$s{height} = $sh;
  $$s{pos} = [$line, 0];
  $$s{window} = newwin($$s{height}, $$s{width}, $$s{pos}[0], $$s{pos}[1]);
  push @{$$screen{windows}}, $s;

  $s = {};
  $$s{code} = "rhost";
  $$s{title} = "Recipient Host";
  $$s{width} = COLS() - int(COLS()/2);
  $$s{height} = $sh;
  $$s{pos} = [$line, int(COLS()/2)];
  $$s{window} = newwin($$s{height}, $$s{width}, $$s{pos}[0], $$s{pos}[1]);
  push @{$$screen{windows}}, $s;

  $line += $sh;

  $s = {};
  $$s{code} = "subject";
  $$s{title} = "Subject";
  $$s{width} = COLS();
  $$s{height} = (LINES() - 2 - ($sh * 3));
  $$s{pos} = [$line, 0];
  $$s{window} = newwin($$s{height}, $$s{width}, $$s{pos}[0], $$s{pos}[1]);
  push @{$$screen{windows}}, $s;

  return $screen;
}


#===============================================================================

sub del_windows
{
  my $screen = shift;

  foreach my $s (@{$$screen{windows}}) {
    delwin($$s{window});
  }
}


#===============================================================================

sub draw_window
{
  my ($s, $d) = @_;
  my $colw = 6;

  attron($$s{window}, A_BOLD);
  attron($$s{window}, A_REVERSE);
  hline($$s{window}, 0, 0, " ", $$s{width});
  addstr($$s{window}, 0, $colw, $$s{title});
  attroff($$s{window}, A_REVERSE);
  attroff($$s{window}, A_BOLD);

  my $time = time() - $highlightafter;
  my $off;

  if (defined $d and defined $$d{$$s{code}}) {
    # fill data in window
    my $line = 1;
    foreach my $data (sort { $$d{$$s{code}}{$b}[0] <=> $$d{$$s{code}}{$a}[0] }
                      keys %{$$d{$$s{code}}}) {
      my $num = sprintf("%5d", $$d{$$s{code}}{$data}[0]);
      my $dstr = substr($data . " " x $$s{width}, 0, $$s{width} - $colw);
      addstr($$s{window}, $line, 0, $num);
      $off = 0;
      if ($$d{$$s{code}}{$data}[3] < $time) {
        attron($$s{window}, COLOR_PAIR(1));
        $off = 1;
      }
      addstr($$s{window}, $line++, $colw, $dstr);
      attroff($$s{window}, COLOR_PAIR(1)) if $off;

      last if $line > $$s{height};
    }
    while ($line < $$s{height}) {
      addstr($$s{window}, $line++, 0, " " x $$s{width});
    }
  }

  refresh($$s{window});
}


#===============================================================================

sub loglinehook
{
  my $lref = shift;

  my %months = ("Jan" => "01", "Feb" => "02", "Mar" => "03", "Apr" => "04",
                "May" => "05", "Jun" => "06", "Jul" => "07", "Aug" => "08",
                "Sep" => "09", "Oct" => "10", "Nov" => "11", "Dec" => "12");

  my @d = localtime;
  my $year = $d[5] + 1900;

  if ($$lref =~ /^(\w{3}) ([0-9 ]{2}) (\d\d:\d\d:\d\d) (\w+) exim\[\d+\]: (.*)$/) {
    my ($mon, $day, $time, $host, $log) = ($1, $2, $3, $4, $5);
    $mon = $months{$mon};
    $day =~ s/^\s/0/;
    $$lref = "$year-$mon-$day $time +0000 $log";
  }
}


# vi:expandtab:sw=2:ts=2:comments=:si:commentstring=
